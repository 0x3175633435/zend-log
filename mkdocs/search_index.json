{
    "docs": [
        {
            "location": "/", 
            "text": "zend-log\n\n\n\n\n\n\nZend\\Log\n is a component for general purpose logging. It supports multiple log\nbackends, formatting messages sent to the log, and filtering messages from being\nlogged.\n\n\n\n\nFile issues at https://github.com/zendframework/zend-log/issues\n\n\nDocumentation is at https://zendframework.github.io/zend-log/", 
            "title": "Home"
        }, 
        {
            "location": "/#zend-log", 
            "text": "Zend\\Log  is a component for general purpose logging. It supports multiple log\nbackends, formatting messages sent to the log, and filtering messages from being\nlogged.   File issues at https://github.com/zendframework/zend-log/issues  Documentation is at https://zendframework.github.io/zend-log/", 
            "title": "zend-log"
        }, 
        {
            "location": "/intro/", 
            "text": "Overview\n\n\nZend\\Log\\Logger\n is a component for general purpose logging. It supports\nmultiple log backends, formatting messages sent to the log, and filtering\nmessages from being logged. These functions are divided into the following\nobjects:\n\n\n\n\nA \nlogger\n (instance of \nZend\\Log\\Logger\n) is the object that your application\n  uses the most. You can have as many logger objects as you like; they do not\n  interact. A logger object must contain at least one \nwriter\n, and can optionally\n  contain one or more \nfilters\n.\n\n\nA \nwriter\n (inherits from \nZend\\Log\\Writer\\AbstractWriter\n) writes data to\n  an underlying storage implementation.\n\n\nA \nfilter\n (implements \nZend\\Log\\Filter\\FilterInterface\n) filters (blocks)\n  log data from being saved. A filter is applied to an individual writer.\n  Filters can be chained.\n\n\nA \nformatter\n (implements \nZend\\Log\\Formatter\\FormatterInterface\n) formats\n  the log data before it is written by a writer. Each writer has exactly one\n  formatter.\n\n\nA \nprocessor\n (implements \nZend\\Log\\Processor\\ProcessorInterface\n) processes\n  the log event prior to filtering or writing, allowing the ability to\n  substitute, add, remove, or modify data to be logged.\n\n\n\n\nCreating a Log\n\n\nTo get started logging, instantiate a writer and then pass it to a logger instance:\n\n\n$logger = new Zend\\Log\\Logger;\n$writer = new Zend\\Log\\Writer\\Stream('php://output');\n\n$logger-\naddWriter($writer);\n\n\n\n\nIt is important to note that the logger must have at least one writer. You can\nadd any number of writers using the logger's \naddWriter()\n method.\n\n\nYou can also add a priority to each writer. The priority is specified as an\ninteger and passed as the second argument in the \naddWriter()\n method.\n\n\nAnother way to add a writer to a logger is to use the name of the writer as\nfollow:\n\n\n$logger = new Zend\\Log\\Logger;\n\n$logger-\naddWriter('stream', null, ['stream' =\n 'php://output']);\n\n\n\n\nIn this example we passed the stream \nphp://output\n as a parameter (via an\noptions array).\n\n\nLogging Messages\n\n\nTo log a message, call the \nlog()\n method of a \nLogger\n instance and pass it the\nmessage priority and the message:\n\n\n$logger-\nlog(Zend\\Log\\Logger::INFO, 'Informational message');\n\n\n\n\nThe first parameter of the \nlog()\n method is the integer \npriority\n and the\nsecond parameter is the string \nmessage\n. The priority must be one of the\npriorities recognized by the \nLogger\n instance (explained in the next section).\nThere is also an optional third parameter used to pass extra\ninformation/metadata to the writer.\n\n\nInstead of using the \nlog()\n method, you can optionally call methods named after\nthe various supported priorities, which allows you to omit the \npriority\n\nargument:\n\n\n$logger-\nlog(Zend\\Log\\Logger::INFO, 'Informational message');\n$logger-\ninfo('Informational message');\n\n$logger-\nlog(Zend\\Log\\Logger::EMERG, 'Emergency message');\n$logger-\nemerg('Emergency message');\n\n\n\n\nDestroying a Log\n\n\nIf the \nLogger\n instance is no longer needed, set the variable containing it to\n\nNULL\n to destroy it.  This will automatically call the \nshutdown()\n instance\nmethod of each attached writer before the \nLogger\n instance is destroyed.\n\n\n$logger = null;\n\n\n\n\nExplicitly destroying the log in this way is optional and is performed\nautomatically at PHP shutdown.\n\n\nUsing Built-in Priorities\n\n\nThe \nZend\\Log\\Logger\n class defines the following priorities:\n\n\nEMERG   = 0;  // Emergency: system is unusable\nALERT   = 1;  // Alert: action must be taken immediately\nCRIT    = 2;  // Critical: critical conditions\nERR     = 3;  // Error: error conditions\nWARN    = 4;  // Warning: warning conditions\nNOTICE  = 5;  // Notice: normal but significant condition\nINFO    = 6;  // Informational: informational messages\nDEBUG   = 7;  // Debug: debug messages\n\n\n\n\nThese priorities are always available, and a convenience method of the same name\n(but lowercased) is available for each one.\n\n\nThe priorities are not arbitrary. They come from the BSD syslog protocol, which\nis described in \nRFC-3164\n. The names and\ncorresponding priority numbers are also compatible with another PHP logging\nsystem, \nPEAR Log\n, which perhaps promotes\ninteroperability between it and \nZend\\Log\\Logger\n;\n\nPSR-3\n uses similar semantics, but without\nthe explicit priority integers.\n\n\nPriority numbers descend in order of importance. \nEMERG\n (0) is the most\nimportant priority. \nDEBUG\n (7) is the least important priority of the built-in\npriorities. You may define priorities of lower importance than \nDEBUG\n. When\nselecting the priority for your log message, be aware of this priority hierarchy\nand choose appropriately.\n\n\nUnderstanding Log Events\n\n\nWhen you call the \nlog()\n method or one of its shortcuts, a log event is\ncreated. This is simply an associative array with data describing the event that\nis passed to the writers. The following keys are always created in this array:\n\n\n\n\ntimestamp\n\n\nmessage\n\n\npriority\n\n\npriorityName\n\n\n\n\nThe creation of the \nevent\n array is an internal detail of implementation.\n\n\nLog PHP Errors\n\n\nZend\\Log\\Logger\n can also be used to log PHP errors and intercept exceptions.\nCalling the static method \nregisterErrorHandler($logger)\n will register the\n\n$logger\n instance to log errors; it returns a boolean \nfalse\n ensuring that it\nreturns delegation to any other error handlers registered, including the default\nPHP error handler.\n\n\n$logger = new Zend\\Log\\Logger;\n$writer = new Zend\\Log\\Writer\\Stream('php://output');\n\n$logger-\naddWriter($writer);\n\nZend\\Log\\Logger::registerErrorHandler($logger);\n\n\n\n\nIf you want to unregister the error handler, can use the \nunregisterErrorHandler()\n static\nmethod.\n\n\nYou can also configure a logger to intercept exceptions using the static method\n\nregisterExceptionHandler($logger)\n.", 
            "title": "Introduction"
        }, 
        {
            "location": "/intro/#overview", 
            "text": "Zend\\Log\\Logger  is a component for general purpose logging. It supports\nmultiple log backends, formatting messages sent to the log, and filtering\nmessages from being logged. These functions are divided into the following\nobjects:   A  logger  (instance of  Zend\\Log\\Logger ) is the object that your application\n  uses the most. You can have as many logger objects as you like; they do not\n  interact. A logger object must contain at least one  writer , and can optionally\n  contain one or more  filters .  A  writer  (inherits from  Zend\\Log\\Writer\\AbstractWriter ) writes data to\n  an underlying storage implementation.  A  filter  (implements  Zend\\Log\\Filter\\FilterInterface ) filters (blocks)\n  log data from being saved. A filter is applied to an individual writer.\n  Filters can be chained.  A  formatter  (implements  Zend\\Log\\Formatter\\FormatterInterface ) formats\n  the log data before it is written by a writer. Each writer has exactly one\n  formatter.  A  processor  (implements  Zend\\Log\\Processor\\ProcessorInterface ) processes\n  the log event prior to filtering or writing, allowing the ability to\n  substitute, add, remove, or modify data to be logged.", 
            "title": "Overview"
        }, 
        {
            "location": "/intro/#creating-a-log", 
            "text": "To get started logging, instantiate a writer and then pass it to a logger instance:  $logger = new Zend\\Log\\Logger;\n$writer = new Zend\\Log\\Writer\\Stream('php://output');\n\n$logger- addWriter($writer);  It is important to note that the logger must have at least one writer. You can\nadd any number of writers using the logger's  addWriter()  method.  You can also add a priority to each writer. The priority is specified as an\ninteger and passed as the second argument in the  addWriter()  method.  Another way to add a writer to a logger is to use the name of the writer as\nfollow:  $logger = new Zend\\Log\\Logger;\n\n$logger- addWriter('stream', null, ['stream' =  'php://output']);  In this example we passed the stream  php://output  as a parameter (via an\noptions array).", 
            "title": "Creating a Log"
        }, 
        {
            "location": "/intro/#logging-messages", 
            "text": "To log a message, call the  log()  method of a  Logger  instance and pass it the\nmessage priority and the message:  $logger- log(Zend\\Log\\Logger::INFO, 'Informational message');  The first parameter of the  log()  method is the integer  priority  and the\nsecond parameter is the string  message . The priority must be one of the\npriorities recognized by the  Logger  instance (explained in the next section).\nThere is also an optional third parameter used to pass extra\ninformation/metadata to the writer.  Instead of using the  log()  method, you can optionally call methods named after\nthe various supported priorities, which allows you to omit the  priority \nargument:  $logger- log(Zend\\Log\\Logger::INFO, 'Informational message');\n$logger- info('Informational message');\n\n$logger- log(Zend\\Log\\Logger::EMERG, 'Emergency message');\n$logger- emerg('Emergency message');", 
            "title": "Logging Messages"
        }, 
        {
            "location": "/intro/#destroying-a-log", 
            "text": "If the  Logger  instance is no longer needed, set the variable containing it to NULL  to destroy it.  This will automatically call the  shutdown()  instance\nmethod of each attached writer before the  Logger  instance is destroyed.  $logger = null;  Explicitly destroying the log in this way is optional and is performed\nautomatically at PHP shutdown.", 
            "title": "Destroying a Log"
        }, 
        {
            "location": "/intro/#using-built-in-priorities", 
            "text": "The  Zend\\Log\\Logger  class defines the following priorities:  EMERG   = 0;  // Emergency: system is unusable\nALERT   = 1;  // Alert: action must be taken immediately\nCRIT    = 2;  // Critical: critical conditions\nERR     = 3;  // Error: error conditions\nWARN    = 4;  // Warning: warning conditions\nNOTICE  = 5;  // Notice: normal but significant condition\nINFO    = 6;  // Informational: informational messages\nDEBUG   = 7;  // Debug: debug messages  These priorities are always available, and a convenience method of the same name\n(but lowercased) is available for each one.  The priorities are not arbitrary. They come from the BSD syslog protocol, which\nis described in  RFC-3164 . The names and\ncorresponding priority numbers are also compatible with another PHP logging\nsystem,  PEAR Log , which perhaps promotes\ninteroperability between it and  Zend\\Log\\Logger ; PSR-3  uses similar semantics, but without\nthe explicit priority integers.  Priority numbers descend in order of importance.  EMERG  (0) is the most\nimportant priority.  DEBUG  (7) is the least important priority of the built-in\npriorities. You may define priorities of lower importance than  DEBUG . When\nselecting the priority for your log message, be aware of this priority hierarchy\nand choose appropriately.", 
            "title": "Using Built-in Priorities"
        }, 
        {
            "location": "/intro/#understanding-log-events", 
            "text": "When you call the  log()  method or one of its shortcuts, a log event is\ncreated. This is simply an associative array with data describing the event that\nis passed to the writers. The following keys are always created in this array:   timestamp  message  priority  priorityName   The creation of the  event  array is an internal detail of implementation.", 
            "title": "Understanding Log Events"
        }, 
        {
            "location": "/intro/#log-php-errors", 
            "text": "Zend\\Log\\Logger  can also be used to log PHP errors and intercept exceptions.\nCalling the static method  registerErrorHandler($logger)  will register the $logger  instance to log errors; it returns a boolean  false  ensuring that it\nreturns delegation to any other error handlers registered, including the default\nPHP error handler.  $logger = new Zend\\Log\\Logger;\n$writer = new Zend\\Log\\Writer\\Stream('php://output');\n\n$logger- addWriter($writer);\n\nZend\\Log\\Logger::registerErrorHandler($logger);  If you want to unregister the error handler, can use the  unregisterErrorHandler()  static\nmethod.  You can also configure a logger to intercept exceptions using the static method registerExceptionHandler($logger) .", 
            "title": "Log PHP Errors"
        }, 
        {
            "location": "/writers/", 
            "text": "Writers\n\n\nA \nwriter\n is an object that inherits from \nZend\\Log\\Writer\\AbstractWriter\n.\nA writer's responsibility is to record log data to a storage backend.\n\n\nWriting to Streams\n\n\nZend\\Log\\Writer\\Stream\n sends log data to a \nPHP stream\n.\n\n\nTo write log data to the PHP output buffer, use the \nphp://output\n stream.\nAlternately, you can send log data directly to a stream like \nSTDERR\n\n(\nphp://stderr\n).\n\n\n$writer = new Zend\\Log\\Writer\\Stream('php://output');\n$logger = new Zend\\Log\\Logger();\n$logger-\naddWriter($writer);\n\n$logger-\ninfo('Informational message');\n\n\n\n\nTo write data to a file, use one of the \nfilesystem\nstreams\n:\n\n\n$writer = new Zend\\Log\\Writer\\Stream('/path/to/logfile');\n$logger = new Zend\\Log\\Logger();\n$logger-\naddWriter($writer);\n\n$logger-\ninfo('Informational message');\n\n\n\n\nBy default, the stream opens in the append access mode (\"a\"). To open it with a\ndifferent access mode, the \nZend\\Log\\Writer\\Stream\n constructor accepts an\noptional second parameter for the stream mode.\n\n\nThe constructor of \nZend\\Log\\Writer\\Stream\n also accepts an existing stream resource:\n\n\n$stream = @fopen('/path/to/logfile', 'a', false);\nif (! $stream) {\n    throw new Exception('Failed to open stream');\n}\n\n$writer = new Zend\\Log\\Writer\\Stream($stream);\n$logger = new Zend\\Log\\Logger();\n$logger-\naddWriter($writer);\n\n$logger-\ninfo('Informational message');\n\n\n\n\nYou cannot specify the stream access mode for existing stream resources. Doing\nso causes a \nZend\\Log\\Exception\n to be thrown.\n\n\nYou can use an array of options in place of the stream argument when\nconstructing a \nStream\n instance; when doing so, the \nstream\n key is required:\n\n\n$writer = new Zend\\Log\\Writer\\Stream([\n    'stream' =\n 'php://output',\n]);\n$logger = new Zend\\Log\\Logger();\n$logger-\naddWriter($writer);\n\n$logger-\ninfo('Informational message');\n\n\n\n\nThe following table details all allowed constructor arguments and their\ncorresponding configuration options.\n\n\n\n\n\n\n\n\nConstructor Argument\n\n\nOption Name\n\n\nDefault\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\n$streamOrUrl\n\n\nstream\n\n\nNone; required\n\n\nStream resource or URL to open and log to\n\n\n\n\n\n\n$mode\n\n\nmode\n\n\n\"a\"\n\n\nStream access mode to use when opening a stream URL\n\n\n\n\n\n\n$logSeparator\n\n\nlog_separator\n\n\nPHP_EOL\n\n\nSeparator string to use between entries\n\n\n\n\n\n\n$filePermissions\n\n\nchmod\n\n\nnull\n\n\nPermissions mode to use for stream resource; defaults to existing file/stream permissions\n\n\n\n\n\n\n\n\nWriting to Databases\n\n\nZend\\Log\\Writer\\Db\n writes log information to a database table using\n\nZend\\Db\\Adapter\\Adapter\n. The constructor of \nZend\\Log\\Writer\\Db\n receives a\n\nZend\\Db\\Adapter\\Adapter\n instance, a table name, an optional mapping of event\ndata to database columns, and an optional string contains the character\nseparator for the log array:\n\n\n$dbconfig = [\n    // Sqlite Configuration\n    'driver' =\n 'Pdo',\n    'dsn' =\n 'sqlite:' . __DIR__ . '/tmp/sqlite.db',\n];\n$db = new Zend\\Db\\Adapter\\Adapter($dbconfig);\n\n$writer = new Zend\\Log\\Writer\\Db($db, 'log_table_name');\n$logger = new Zend\\Log\\Logger();\n$logger-\naddWriter($writer);\n\n$logger-\ninfo('Informational message');\n\n\n\n\nThe example above writes a single row of log data to the database table named\n\nlog_table_name\n table. The database columns will be created according to the\nevent array generated by the \nZend\\Log\\Logger\n instance.\n\n\nIf we specify the mapping of the events with the database columns, the log will\nstore only to the selected fields in the database:\n\n\n$dbconfig = [\n    // Sqlite Configuration\n    'driver' =\n 'Pdo',\n    'dsn' =\n 'sqlite:' . __DIR__ . '/tmp/sqlite.db',\n];\n$db = new Zend\\Db\\Adapter\\Adapter($dbconfig);\n\n$mapping = [\n    'timestamp' =\n 'date',\n    'priority'  =\n 'type',\n    'message'   =\n 'event',\n];\n$writer = new Zend\\Log\\Writer\\Db($db, 'log_table_name', $mapping);\n$logger = new Zend\\Log\\Logger();\n$logger-\naddWriter($writer);\n\n$logger-\ninfo('Informational message');\n\n\n\n\nIn this example, the writer stores only the log timestamp, priority, and\nmessage, in the database fields date, type, and event, respectively.\n\n\nZend\\Log\\Writer\\Db\n has a fourth optional parameter in the constructor. This\nparameter is the character separator for array fields in the log event. For\ninstance, if we have a log event that contains the field \nextra\n, and that field\nis an array, its elements will be translated as 'extra-field', where '-' is the\ncharacter separator (default), and 'field' is the subname of the specific field\nfound in the \nextra\n array.\n\n\nWriting to FirePHP\n\n\nZend\\Log\\Writer\\FirePHP\n writes log information to the\n\nFirePHP\n Firefox extension. In order to use it, you\nmust install the FirePHPCore server library and the FirePHP browser extension.\n\n\nTo install the FirePHPCore library you can use\n\nComposer\n:\n\n\n$ composer require firephp/firephp-core\n\n\n\n\nWriting to ChromePHP\n\n\nZend\\Log\\Writer\\ChromePHP\n sends log data to the\n\nChromePHP\n\nChrome extension.\n\n\nTo use the ChromePHP writer, you will also need to include the \nChromePHP\nLibrary\n library in your application. Use\n\nComposer\n to do this:\n\n\n$ composer require ccampbell/chromephp\n\n\n\n\nWriting to Mail\n\n\n\n\nTODO\n\n\n\n\nWriting to MongoDB\n\n\n\n\nTODO\n\n\n\n\nWriting to Syslog\n\n\n\n\nTODO\n\n\n\n\nWriting to Zend Monitor\n\n\n\n\nTODO\n\n\n\n\nStubbing Out the Writer\n\n\nZend\\Log\\Writer\\Noop\n is a stub that does not write log data to anything; it is\nuseful for disabling logging or stubbing out logging during tests:\n\n\n$writer = new Zend\\Log\\Writer\\Noop;\n$logger = new Zend\\Log\\Logger();\n$logger-\naddWriter($writer);\n\n// goes nowhere\n$logger-\ninfo('Informational message');\n\n\n\n\nMigration from 2.0-2.3 to 2.4+\n\n\nVersion 2.4 adds support for PHP 7. In PHP 7, \nnull\n is a reserved keyword, which required renaming\nthe \nNull\n log writer. If you were using the \nNull\n writer directly previously, you will now receive\nan \nE_USER_DEPRECATED\n notice on instantiation. Please update your code to refer to the \nNoop\n class\ninstead.\n\n\nUsers pulling their \nNull\n writer instance from the writer plugin manager receive a \nNoop\n instance\ninstead starting in 2.4.0.\n\n\nTesting with the Mock Writer\n\n\nZend\\Log\\Writer\\Mock\n is a simple writer that records the raw data it receives\nin an array that it exposes as a public property.\n\n\n$mock = new Zend\\Log\\Writer\\Mock;\n$logger = new Zend\\Log\\Logger();\n$logger-\naddWriter($mock);\n\n$logger-\ninfo('Informational message');\n\nvar_dump($mock-\nevents[0]);\n\n// Array\n// (\n//    [timestamp] =\n 2007-04-06T07:16:37-07:00\n//    [message] =\n Informational message\n//    [priority] =\n 6\n//    [priorityName] =\n INFO\n// )\n\n\n\n\nTo clear the events logged by the mock, reset the \n$events\n property:\n\n\n$mock-\nevents = [];\n\n\n\n\nCompositing Writers\n\n\nThere is no composite writer object. However, a \nLogger\n instance can write to\nany number of writers, effectively making it a composite logger.\n\n\nTo utilize this functionality, add writers via the \nLogger::addWriter()\n method:\n\n\n$writer1 = new Zend\\Log\\Writer\\Stream('/path/to/first/logfile');\n$writer2 = new Zend\\Log\\Writer\\Stream('/path/to/second/logfile');\n\n$logger = new Zend\\Log\\Logger();\n$logger-\naddWriter($writer1);\n$logger-\naddWriter($writer2);\n\n// goes to both writers\n$logger-\ninfo('Informational message');\n\n\n\n\nYou can also specify the priority number for each writer to change the order of writing. The\npriority number is an integer number passed as second parameter in the\n\naddWriter()\n method. Internally, \nSplPriorityQueue\n is used to manage writers,\nwhich means that:\n\n\n\n\nhigher integer values indicate higher priority (triggered earliest);\n\n\nlower integer values (including negative values) have lower priority\n  (triggered last).", 
            "title": "Writers"
        }, 
        {
            "location": "/writers/#writers", 
            "text": "A  writer  is an object that inherits from  Zend\\Log\\Writer\\AbstractWriter .\nA writer's responsibility is to record log data to a storage backend.", 
            "title": "Writers"
        }, 
        {
            "location": "/writers/#writing-to-streams", 
            "text": "Zend\\Log\\Writer\\Stream  sends log data to a  PHP stream .  To write log data to the PHP output buffer, use the  php://output  stream.\nAlternately, you can send log data directly to a stream like  STDERR \n( php://stderr ).  $writer = new Zend\\Log\\Writer\\Stream('php://output');\n$logger = new Zend\\Log\\Logger();\n$logger- addWriter($writer);\n\n$logger- info('Informational message');  To write data to a file, use one of the  filesystem\nstreams :  $writer = new Zend\\Log\\Writer\\Stream('/path/to/logfile');\n$logger = new Zend\\Log\\Logger();\n$logger- addWriter($writer);\n\n$logger- info('Informational message');  By default, the stream opens in the append access mode (\"a\"). To open it with a\ndifferent access mode, the  Zend\\Log\\Writer\\Stream  constructor accepts an\noptional second parameter for the stream mode.  The constructor of  Zend\\Log\\Writer\\Stream  also accepts an existing stream resource:  $stream = @fopen('/path/to/logfile', 'a', false);\nif (! $stream) {\n    throw new Exception('Failed to open stream');\n}\n\n$writer = new Zend\\Log\\Writer\\Stream($stream);\n$logger = new Zend\\Log\\Logger();\n$logger- addWriter($writer);\n\n$logger- info('Informational message');  You cannot specify the stream access mode for existing stream resources. Doing\nso causes a  Zend\\Log\\Exception  to be thrown.  You can use an array of options in place of the stream argument when\nconstructing a  Stream  instance; when doing so, the  stream  key is required:  $writer = new Zend\\Log\\Writer\\Stream([\n    'stream' =  'php://output',\n]);\n$logger = new Zend\\Log\\Logger();\n$logger- addWriter($writer);\n\n$logger- info('Informational message');  The following table details all allowed constructor arguments and their\ncorresponding configuration options.     Constructor Argument  Option Name  Default  Description      $streamOrUrl  stream  None; required  Stream resource or URL to open and log to    $mode  mode  \"a\"  Stream access mode to use when opening a stream URL    $logSeparator  log_separator  PHP_EOL  Separator string to use between entries    $filePermissions  chmod  null  Permissions mode to use for stream resource; defaults to existing file/stream permissions", 
            "title": "Writing to Streams"
        }, 
        {
            "location": "/writers/#writing-to-databases", 
            "text": "Zend\\Log\\Writer\\Db  writes log information to a database table using Zend\\Db\\Adapter\\Adapter . The constructor of  Zend\\Log\\Writer\\Db  receives a Zend\\Db\\Adapter\\Adapter  instance, a table name, an optional mapping of event\ndata to database columns, and an optional string contains the character\nseparator for the log array:  $dbconfig = [\n    // Sqlite Configuration\n    'driver' =  'Pdo',\n    'dsn' =  'sqlite:' . __DIR__ . '/tmp/sqlite.db',\n];\n$db = new Zend\\Db\\Adapter\\Adapter($dbconfig);\n\n$writer = new Zend\\Log\\Writer\\Db($db, 'log_table_name');\n$logger = new Zend\\Log\\Logger();\n$logger- addWriter($writer);\n\n$logger- info('Informational message');  The example above writes a single row of log data to the database table named log_table_name  table. The database columns will be created according to the\nevent array generated by the  Zend\\Log\\Logger  instance.  If we specify the mapping of the events with the database columns, the log will\nstore only to the selected fields in the database:  $dbconfig = [\n    // Sqlite Configuration\n    'driver' =  'Pdo',\n    'dsn' =  'sqlite:' . __DIR__ . '/tmp/sqlite.db',\n];\n$db = new Zend\\Db\\Adapter\\Adapter($dbconfig);\n\n$mapping = [\n    'timestamp' =  'date',\n    'priority'  =  'type',\n    'message'   =  'event',\n];\n$writer = new Zend\\Log\\Writer\\Db($db, 'log_table_name', $mapping);\n$logger = new Zend\\Log\\Logger();\n$logger- addWriter($writer);\n\n$logger- info('Informational message');  In this example, the writer stores only the log timestamp, priority, and\nmessage, in the database fields date, type, and event, respectively.  Zend\\Log\\Writer\\Db  has a fourth optional parameter in the constructor. This\nparameter is the character separator for array fields in the log event. For\ninstance, if we have a log event that contains the field  extra , and that field\nis an array, its elements will be translated as 'extra-field', where '-' is the\ncharacter separator (default), and 'field' is the subname of the specific field\nfound in the  extra  array.", 
            "title": "Writing to Databases"
        }, 
        {
            "location": "/writers/#writing-to-firephp", 
            "text": "Zend\\Log\\Writer\\FirePHP  writes log information to the FirePHP  Firefox extension. In order to use it, you\nmust install the FirePHPCore server library and the FirePHP browser extension.  To install the FirePHPCore library you can use Composer :  $ composer require firephp/firephp-core", 
            "title": "Writing to FirePHP"
        }, 
        {
            "location": "/writers/#writing-to-chromephp", 
            "text": "Zend\\Log\\Writer\\ChromePHP  sends log data to the ChromePHP \nChrome extension.  To use the ChromePHP writer, you will also need to include the  ChromePHP\nLibrary  library in your application. Use Composer  to do this:  $ composer require ccampbell/chromephp", 
            "title": "Writing to ChromePHP"
        }, 
        {
            "location": "/writers/#writing-to-mail", 
            "text": "TODO", 
            "title": "Writing to Mail"
        }, 
        {
            "location": "/writers/#writing-to-mongodb", 
            "text": "TODO", 
            "title": "Writing to MongoDB"
        }, 
        {
            "location": "/writers/#writing-to-syslog", 
            "text": "TODO", 
            "title": "Writing to Syslog"
        }, 
        {
            "location": "/writers/#writing-to-zend-monitor", 
            "text": "TODO", 
            "title": "Writing to Zend Monitor"
        }, 
        {
            "location": "/writers/#stubbing-out-the-writer", 
            "text": "Zend\\Log\\Writer\\Noop  is a stub that does not write log data to anything; it is\nuseful for disabling logging or stubbing out logging during tests:  $writer = new Zend\\Log\\Writer\\Noop;\n$logger = new Zend\\Log\\Logger();\n$logger- addWriter($writer);\n\n// goes nowhere\n$logger- info('Informational message');", 
            "title": "Stubbing Out the Writer"
        }, 
        {
            "location": "/writers/#migration-from-20-23-to-24", 
            "text": "Version 2.4 adds support for PHP 7. In PHP 7,  null  is a reserved keyword, which required renaming\nthe  Null  log writer. If you were using the  Null  writer directly previously, you will now receive\nan  E_USER_DEPRECATED  notice on instantiation. Please update your code to refer to the  Noop  class\ninstead.  Users pulling their  Null  writer instance from the writer plugin manager receive a  Noop  instance\ninstead starting in 2.4.0.", 
            "title": "Migration from 2.0-2.3 to 2.4+"
        }, 
        {
            "location": "/writers/#testing-with-the-mock-writer", 
            "text": "Zend\\Log\\Writer\\Mock  is a simple writer that records the raw data it receives\nin an array that it exposes as a public property.  $mock = new Zend\\Log\\Writer\\Mock;\n$logger = new Zend\\Log\\Logger();\n$logger- addWriter($mock);\n\n$logger- info('Informational message');\n\nvar_dump($mock- events[0]);\n\n// Array\n// (\n//    [timestamp] =  2007-04-06T07:16:37-07:00\n//    [message] =  Informational message\n//    [priority] =  6\n//    [priorityName] =  INFO\n// )  To clear the events logged by the mock, reset the  $events  property:  $mock- events = [];", 
            "title": "Testing with the Mock Writer"
        }, 
        {
            "location": "/writers/#compositing-writers", 
            "text": "There is no composite writer object. However, a  Logger  instance can write to\nany number of writers, effectively making it a composite logger.  To utilize this functionality, add writers via the  Logger::addWriter()  method:  $writer1 = new Zend\\Log\\Writer\\Stream('/path/to/first/logfile');\n$writer2 = new Zend\\Log\\Writer\\Stream('/path/to/second/logfile');\n\n$logger = new Zend\\Log\\Logger();\n$logger- addWriter($writer1);\n$logger- addWriter($writer2);\n\n// goes to both writers\n$logger- info('Informational message');  You can also specify the priority number for each writer to change the order of writing. The\npriority number is an integer number passed as second parameter in the addWriter()  method. Internally,  SplPriorityQueue  is used to manage writers,\nwhich means that:   higher integer values indicate higher priority (triggered earliest);  lower integer values (including negative values) have lower priority\n  (triggered last).", 
            "title": "Compositing Writers"
        }, 
        {
            "location": "/filters/", 
            "text": "Filters\n\n\nA \nfilter\n prevents a message from being written to the log.\n\n\nYou can add a filter to a specific writer using the \naddFilter()\n method of the\nwriter:\n\n\nuse Zend\\Log\\Logger;\n\n$logger = new Logger();\n\n$writer1 = new Zend\\Log\\Writer\\Stream('/path/to/first/logfile');\n$logger-\naddWriter($writer1);\n\n$writer2 = new Zend\\Log\\Writer\\Stream('/path/to/second/logfile');\n$logger-\naddWriter($writer2);\n\n// add a filter only to writer2\n$filter = new Zend\\Log\\Filter\\Priority(Logger::CRIT);\n$writer2-\naddFilter($filter);\n\n// logged to writer1, blocked from writer2\n$logger-\ninfo('Informational message');\n\n// logged by both writers\n$logger-\nemerg('Emergency message');\n\n\n\n\nAvailable filters\n\n\n\n\n\n\n\n\nFilter Class\n\n\nShort Name\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nZend\\Log\\Filter\\Priority\n\n\nPriority\n\n\nFilter logging by \n$priority\n. By default, it will accept any log event whose priority value is less than or equal to \n$priority\n.\n\n\n\n\n\n\nZend\\Log\\Filter\\Regex\n\n\nRegex\n\n\nFilter out any log messages not matching the regex pattern. This filter uses the \npreg_match()\n function.\n\n\n\n\n\n\nZend\\Log\\Filter\\Timestamp\n\n\nTimestamp\n\n\nFilters log events based on the time when they were triggered. It can be configured by specifying either \nidate()\n-compliant format characters along with the desired value, or a full \nDateTime\n instance. An appropriate comparison operator must be supplied in either case.\n\n\n\n\n\n\nZend\\Log\\Filter\\SuppressFilter\n\n\nSuppressFilter\n\n\nA simple boolean filter; a boolean \ntrue\n value passed to the constructor suppresses all log events, while a boolean \nfalse\n value accepts all log events.\n\n\n\n\n\n\nZend\\Log\\Filter\\Validator\n\n\nValidator\n\n\nFilter any log messages that fail validaton by the composed \nZend\\Validator\\ValidatorInterface\n implementation.", 
            "title": "Filters"
        }, 
        {
            "location": "/filters/#filters", 
            "text": "A  filter  prevents a message from being written to the log.  You can add a filter to a specific writer using the  addFilter()  method of the\nwriter:  use Zend\\Log\\Logger;\n\n$logger = new Logger();\n\n$writer1 = new Zend\\Log\\Writer\\Stream('/path/to/first/logfile');\n$logger- addWriter($writer1);\n\n$writer2 = new Zend\\Log\\Writer\\Stream('/path/to/second/logfile');\n$logger- addWriter($writer2);\n\n// add a filter only to writer2\n$filter = new Zend\\Log\\Filter\\Priority(Logger::CRIT);\n$writer2- addFilter($filter);\n\n// logged to writer1, blocked from writer2\n$logger- info('Informational message');\n\n// logged by both writers\n$logger- emerg('Emergency message');", 
            "title": "Filters"
        }, 
        {
            "location": "/filters/#available-filters", 
            "text": "Filter Class  Short Name  Description      Zend\\Log\\Filter\\Priority  Priority  Filter logging by  $priority . By default, it will accept any log event whose priority value is less than or equal to  $priority .    Zend\\Log\\Filter\\Regex  Regex  Filter out any log messages not matching the regex pattern. This filter uses the  preg_match()  function.    Zend\\Log\\Filter\\Timestamp  Timestamp  Filters log events based on the time when they were triggered. It can be configured by specifying either  idate() -compliant format characters along with the desired value, or a full  DateTime  instance. An appropriate comparison operator must be supplied in either case.    Zend\\Log\\Filter\\SuppressFilter  SuppressFilter  A simple boolean filter; a boolean  true  value passed to the constructor suppresses all log events, while a boolean  false  value accepts all log events.    Zend\\Log\\Filter\\Validator  Validator  Filter any log messages that fail validaton by the composed  Zend\\Validator\\ValidatorInterface  implementation.", 
            "title": "Available filters"
        }, 
        {
            "location": "/formatters/", 
            "text": "Formatters\n\n\nA \nformatter\n is an object that is responsible for taking an \nevent\n array\ndescribing a log event and outputting a string with a formatted log line.\n\n\nSome writers are not line-oriented, such as the \nDb\n, \nFirePhp\n, and\n\nChromePhp\n writers. For these writers, formatters ensure the individual values\nin the event array are formatted properly for the writer.\n\n\nSimple Formatting\n\n\nZend\\Log\\Formatter\\Simple\n is the default formatter. It is configured automatically when you\nspecify no formatter. The default configuration is equivalent to the following:\n\n\n$format = '%timestamp% %priorityName% (%priority%): %message%' . PHP_EOL;\n$formatter = new Zend\\Log\\Formatter\\Simple($format);\n\n\n\n\nA formatter is set on an individual writer object using the writer's \nsetFormatter()\n method:\n\n\n$writer = new Zend\\Log\\Writer\\Stream('php://output');\n$formatter = new Zend\\Log\\Formatter\\Simple('hello %message%' . PHP_EOL);\n$writer-\nsetFormatter($formatter);\n\n$logger = new Zend\\Log\\Logger();\n$logger-\naddWriter($writer);\n\n$logger-\ninfo('there');\n\n// outputs \nhello there\n\n\n\n\nThe constructor of \nZend\\Log\\Formatter\\Simple\n accepts a single parameter: the\nformat string. This string contains keys surrounded by percent signs (e.g.\n\n%message%\n). The format string may contain any key from the event data array.\nYou can retrieve the default keys by using the \nDEFAULT_FORMAT\n constant from\n\nZend\\Log\\Formatter\\Simple\n.\n\n\nFormatting to XML\n\n\nZend\\Log\\Formatter\\Xml\n formats log data into XML strings. By default, it\nautomatically logs all items in the event array:\n\n\n$writer = new Zend\\Log\\Writer\\Stream('php://output');\n$formatter = new Zend\\Log\\Formatter\\Xml();\n$writer-\nsetFormatter($formatter);\n\n$logger = new Zend\\Log\\Logger();\n$logger-\naddWriter($writer);\n\n$logger-\ninfo('informational message');\n\n\n\n\nThe code above outputs the following XML (space added for clarity):\n\n\nlogEntry\n\n  \ntimestamp\n2007-04-06T07:24:37-07:00\n/timestamp\n\n  \nmessage\ninformational message\n/message\n\n  \npriority\n6\n/priority\n\n  \npriorityName\nINFO\n/priorityName\n\n\n/logEntry\n\n\n\n\nIt's possible to customize the root element, as well as specify a mapping of\nXML elements to the items in the event data array. The constructor of\n\nZend\\Log\\Formatter\\Xml\n accepts a string with the name of the root element as\nthe first parameter, and an associative array with the element mapping as the\nsecond parameter:\n\n\n$writer = new Zend\\Log\\Writer\\Stream('php://output');\n$formatter = new Zend\\Log\\Formatter\\Xml('log', [\n    'msg' =\n 'message',\n    'level' =\n 'priorityName',\n]);\n$writer-\nsetFormatter($formatter);\n\n$logger = new Zend\\Log\\Logger();\n$logger-\naddWriter($writer);\n\n$logger-\ninfo('informational message');\n\n\n\n\nThe code above changes the root element from its default of \nlogEntry\n to\n\nlog\n. It also maps the element \nmsg\n to the event data item \nmessage\n. This\nresults in the following output:\n\n\nlog\n\n  \nmsg\ninformational message\n/msg\n\n  \nlevel\nINFO\n/level\n\n\n/log\n\n\n\n\nFormatting to FirePhp\n\n\nZend\\Log\\Formatter\\FirePhp\n formats log data for the \nFirebug\n extension\nfor Firefox.", 
            "title": "Formatters"
        }, 
        {
            "location": "/formatters/#formatters", 
            "text": "A  formatter  is an object that is responsible for taking an  event  array\ndescribing a log event and outputting a string with a formatted log line.  Some writers are not line-oriented, such as the  Db ,  FirePhp , and ChromePhp  writers. For these writers, formatters ensure the individual values\nin the event array are formatted properly for the writer.", 
            "title": "Formatters"
        }, 
        {
            "location": "/formatters/#simple-formatting", 
            "text": "Zend\\Log\\Formatter\\Simple  is the default formatter. It is configured automatically when you\nspecify no formatter. The default configuration is equivalent to the following:  $format = '%timestamp% %priorityName% (%priority%): %message%' . PHP_EOL;\n$formatter = new Zend\\Log\\Formatter\\Simple($format);  A formatter is set on an individual writer object using the writer's  setFormatter()  method:  $writer = new Zend\\Log\\Writer\\Stream('php://output');\n$formatter = new Zend\\Log\\Formatter\\Simple('hello %message%' . PHP_EOL);\n$writer- setFormatter($formatter);\n\n$logger = new Zend\\Log\\Logger();\n$logger- addWriter($writer);\n\n$logger- info('there');\n\n// outputs  hello there  The constructor of  Zend\\Log\\Formatter\\Simple  accepts a single parameter: the\nformat string. This string contains keys surrounded by percent signs (e.g. %message% ). The format string may contain any key from the event data array.\nYou can retrieve the default keys by using the  DEFAULT_FORMAT  constant from Zend\\Log\\Formatter\\Simple .", 
            "title": "Simple Formatting"
        }, 
        {
            "location": "/formatters/#formatting-to-xml", 
            "text": "Zend\\Log\\Formatter\\Xml  formats log data into XML strings. By default, it\nautomatically logs all items in the event array:  $writer = new Zend\\Log\\Writer\\Stream('php://output');\n$formatter = new Zend\\Log\\Formatter\\Xml();\n$writer- setFormatter($formatter);\n\n$logger = new Zend\\Log\\Logger();\n$logger- addWriter($writer);\n\n$logger- info('informational message');  The code above outputs the following XML (space added for clarity):  logEntry \n   timestamp 2007-04-06T07:24:37-07:00 /timestamp \n   message informational message /message \n   priority 6 /priority \n   priorityName INFO /priorityName  /logEntry  It's possible to customize the root element, as well as specify a mapping of\nXML elements to the items in the event data array. The constructor of Zend\\Log\\Formatter\\Xml  accepts a string with the name of the root element as\nthe first parameter, and an associative array with the element mapping as the\nsecond parameter:  $writer = new Zend\\Log\\Writer\\Stream('php://output');\n$formatter = new Zend\\Log\\Formatter\\Xml('log', [\n    'msg' =  'message',\n    'level' =  'priorityName',\n]);\n$writer- setFormatter($formatter);\n\n$logger = new Zend\\Log\\Logger();\n$logger- addWriter($writer);\n\n$logger- info('informational message');  The code above changes the root element from its default of  logEntry  to log . It also maps the element  msg  to the event data item  message . This\nresults in the following output:  log \n   msg informational message /msg \n   level INFO /level  /log", 
            "title": "Formatting to XML"
        }, 
        {
            "location": "/formatters/#formatting-to-firephp", 
            "text": "Zend\\Log\\Formatter\\FirePhp  formats log data for the  Firebug  extension\nfor Firefox.", 
            "title": "Formatting to FirePhp"
        }, 
        {
            "location": "/processors/", 
            "text": "Processors\n\n\nProcessors\n allow you to provide additional information to logs in an\nautomated fashion. They are called from the logger before the event is passed\nto the writers; they receive the event array, and return an event array on\ncompletion.\n\n\nUse cases include:\n\n\n\n\nProviding exception backtrace information.\n\n\nInjecting substitutions into the message.\n\n\nInjecting a request identifier (in order to later inspect logs for a specific\n  identifier)\n\n\n\n\nProcessor interface\n\n\nAll processors must implement \nZend\\Log\\Processor\\ProcessorInterface\n:\n\n\nnamespace Zend\\Log\\Processor;\n\ninterface ProcessorInterface\n{\n    /**\n     * Processes a log message before it is given to the writers\n     *\n     * @param  array $event\n     * @return array\n     */\n    public function process(array $event);\n}\n\n\n\n\nAdding processors\n\n\nTo add a processor to a \nLogger\n instance, inject it using the \naddProcessor()\n method:\n\n\n$logger-\naddProcessor(new Zend\\Log\\Processor\\Backtrace());\n\n\n\n\nAvailable processors\n\n\nThe following processors are available.\n\n\nBacktrace\n\n\nZend\\Log\\Processor\\Backtrace\n calls \ndebug_backtrace()\n for every log event,\ninjecting the details into the event's \nextra\n array:\n\n\n$event = [\n    // ... standard elements ...\n    'extra' =\n [\n        'file' =\n 'SomeFile.php',\n        'line' =\n 1337,\n        'class' =\n 'Foo\\MyClass',\n        'function' =\n 'myMethod',\n    ],\n];\n\n\n\n\nPsrPlaceholder\n\n\nZend\\Log\\Processor\\PsrPlaceholder\n replaces \nPSR-3\n-formatted\nmessage placeholders with the values found in the \nextra\n array.\n\n\nAs an example:\n\n\n$logger-\naddProcessor(new Zend\\Log\\Processor\\PsrPlaceholder());\n$logger-\nwarn('Invalid plugin {plugin}', ['plugin' =\n 'My\\Plugins\\FooPlugin']);\n\n\n\n\nwill output:\n\n\nInvalid plugin My\\Plugins\\FooPlugin\n\n\n\n\nThis feature allows compatibility with PSR-3, and provides a simple way to\nprovide string substitutions without needing to resort to \nsprintf()\n in\nyour userland code.\n\n\nReferenceId\n\n\nZend\\Log\\Processor\\ReferenceId\n allows you to specify a static reference\nidentifier to inject in all log messages; typically, you will generate a new\none for each request, to allow querying logs for the given reference\nidentifier later.\n\n\nGiven the following:\n\n\n$processor = new Zend\\Log\\Processor\\ReferenceId();\n$processor-\nsetIdentifier(microtime(true) . '_' . uniqid());\n$logger-\naddProcessor($processor);\n$logger-\ninfo('Log event');\n\n\n\n\nThe event will contain:\n\n\n$event = [\n    /* ... standard values ... */\n    'extra' =\n [\n        'referenceId' =\n '1455057110.6284_56ba68ebe1244',\n    ],\n];\n\n\n\n\nRequestId\n\n\nZend\\Log\\Processor\\RequestId\n is similar to \nReferenceId\n with one key\ndifference: if you do not set an identifier, one is automatically\ngenerated for you using hashed information from \n$_SERVER\n, including\n\nREQUEST_TIME_FLOAT\n, \nHTTP_X_FORWARDED_FOR\n, and/or \nREMOTE_ADDR\n.", 
            "title": "Processors"
        }, 
        {
            "location": "/processors/#processors", 
            "text": "Processors  allow you to provide additional information to logs in an\nautomated fashion. They are called from the logger before the event is passed\nto the writers; they receive the event array, and return an event array on\ncompletion.  Use cases include:   Providing exception backtrace information.  Injecting substitutions into the message.  Injecting a request identifier (in order to later inspect logs for a specific\n  identifier)", 
            "title": "Processors"
        }, 
        {
            "location": "/processors/#processor-interface", 
            "text": "All processors must implement  Zend\\Log\\Processor\\ProcessorInterface :  namespace Zend\\Log\\Processor;\n\ninterface ProcessorInterface\n{\n    /**\n     * Processes a log message before it is given to the writers\n     *\n     * @param  array $event\n     * @return array\n     */\n    public function process(array $event);\n}", 
            "title": "Processor interface"
        }, 
        {
            "location": "/processors/#adding-processors", 
            "text": "To add a processor to a  Logger  instance, inject it using the  addProcessor()  method:  $logger- addProcessor(new Zend\\Log\\Processor\\Backtrace());", 
            "title": "Adding processors"
        }, 
        {
            "location": "/processors/#available-processors", 
            "text": "The following processors are available.", 
            "title": "Available processors"
        }, 
        {
            "location": "/processors/#backtrace", 
            "text": "Zend\\Log\\Processor\\Backtrace  calls  debug_backtrace()  for every log event,\ninjecting the details into the event's  extra  array:  $event = [\n    // ... standard elements ...\n    'extra' =  [\n        'file' =  'SomeFile.php',\n        'line' =  1337,\n        'class' =  'Foo\\MyClass',\n        'function' =  'myMethod',\n    ],\n];", 
            "title": "Backtrace"
        }, 
        {
            "location": "/processors/#psrplaceholder", 
            "text": "Zend\\Log\\Processor\\PsrPlaceholder  replaces  PSR-3 -formatted\nmessage placeholders with the values found in the  extra  array.  As an example:  $logger- addProcessor(new Zend\\Log\\Processor\\PsrPlaceholder());\n$logger- warn('Invalid plugin {plugin}', ['plugin' =  'My\\Plugins\\FooPlugin']);  will output:  Invalid plugin My\\Plugins\\FooPlugin  This feature allows compatibility with PSR-3, and provides a simple way to\nprovide string substitutions without needing to resort to  sprintf()  in\nyour userland code.", 
            "title": "PsrPlaceholder"
        }, 
        {
            "location": "/processors/#referenceid", 
            "text": "Zend\\Log\\Processor\\ReferenceId  allows you to specify a static reference\nidentifier to inject in all log messages; typically, you will generate a new\none for each request, to allow querying logs for the given reference\nidentifier later.  Given the following:  $processor = new Zend\\Log\\Processor\\ReferenceId();\n$processor- setIdentifier(microtime(true) . '_' . uniqid());\n$logger- addProcessor($processor);\n$logger- info('Log event');  The event will contain:  $event = [\n    /* ... standard values ... */\n    'extra' =  [\n        'referenceId' =  '1455057110.6284_56ba68ebe1244',\n    ],\n];", 
            "title": "ReferenceId"
        }, 
        {
            "location": "/processors/#requestid", 
            "text": "Zend\\Log\\Processor\\RequestId  is similar to  ReferenceId  with one key\ndifference: if you do not set an identifier, one is automatically\ngenerated for you using hashed information from  $_SERVER , including REQUEST_TIME_FLOAT ,  HTTP_X_FORWARDED_FOR , and/or  REMOTE_ADDR .", 
            "title": "RequestId"
        }, 
        {
            "location": "/psr3/", 
            "text": "PSR-3 Logger Interface compatibility\n\n\nPSR-3 Logger Interface\n\nis a standards recommendation defining a common interface for logging\nlibraries. The \nzend-log\n component predates it, and has minor\nincompatibilities, but starting with version 2.6 provides the following\ncompatibility features:\n\n\n\n\nPSR logger adapter\n\n\nPSR logger writer\n\n\nPSR placeholder processor\n\n\n\n\nPsrLoggerAdapter\n\n\nZend\\Log\\PsrLoggerAdapter\n wraps \nZend\\Log\\LoggerInterface\n, allowing it to be used\nanywhere \nPsr\\Log\\LoggerInterface\n is expected.\n\n\n$zendLogLogger = new Zend\\Log\\Logger;\n\n$psrLogger = new Zend\\Log\\PsrLoggerAdapter($zendLogLogger);\n$psrLogger-\nlog(Psr\\Log\\LogLevel::INFO, 'We have a PSR-compatible logger');\n\n\n\n\nPSR-3 log writer\n\n\nZend\\Log\\Writer\\Psr\n allows log messages and extras to be forwared to any\nPSR-3 compatible logger. As with any log writer, this has the added benefit\nthat your filters can be used to limit forwarded messages.\n\n\nThe writer needs a \nPsr\\Logger\\LoggerInterface\n instance to be useful, and\nfalls back to \nPsr\\Log\\NullLogger\n if none is provided. There are three ways to\nprovide the PSR logger instance to the log writer:\n\n\n// Via constructor parameter:\n$writer = new Zend\\Log\\Writer\\Psr($psrLogger);\n\n// Via option:\n$writer = new Zend\\Log\\Writer\\Psr(['logger' =\n $psrLogger]);\n\n// Via setter injection:\n$writer = new Zend\\Log\\Writer\\Psr();\n$writer-\nsetLogger($psrLogger);\n\n\n\n\nPSR-3 placeholder processor\n\n\nZend\\Log\\Processor\\PsrPlaceholder\n adds support for \nPSR-3 message placeholders\n.\nPlaceholder names correspond to keys in the \"extra\" array passed when logging\na message.\n\n\nValues can be of arbitrary type, including all scalars, and objects\nimplementing \n__toString\n; objects not capable of string serialization will\nresult in the fully-qualified class name being substituted.\n\n\n$logger = new Zend\\Log\\Logger;\n$logger-\naddProcessor(new Zend\\Log\\Processor\\PsrPlaceholder);\n\n$logger-\ninfo('User with email {email} registered', ['email' =\n 'user@example.org']);\n// logs message 'User with email user@example.org registered'", 
            "title": "PSR-3 Support"
        }, 
        {
            "location": "/psr3/#psr-3-logger-interface-compatibility", 
            "text": "PSR-3 Logger Interface \nis a standards recommendation defining a common interface for logging\nlibraries. The  zend-log  component predates it, and has minor\nincompatibilities, but starting with version 2.6 provides the following\ncompatibility features:   PSR logger adapter  PSR logger writer  PSR placeholder processor", 
            "title": "PSR-3 Logger Interface compatibility"
        }, 
        {
            "location": "/psr3/#psrloggeradapter", 
            "text": "Zend\\Log\\PsrLoggerAdapter  wraps  Zend\\Log\\LoggerInterface , allowing it to be used\nanywhere  Psr\\Log\\LoggerInterface  is expected.  $zendLogLogger = new Zend\\Log\\Logger;\n\n$psrLogger = new Zend\\Log\\PsrLoggerAdapter($zendLogLogger);\n$psrLogger- log(Psr\\Log\\LogLevel::INFO, 'We have a PSR-compatible logger');", 
            "title": "PsrLoggerAdapter"
        }, 
        {
            "location": "/psr3/#psr-3-log-writer", 
            "text": "Zend\\Log\\Writer\\Psr  allows log messages and extras to be forwared to any\nPSR-3 compatible logger. As with any log writer, this has the added benefit\nthat your filters can be used to limit forwarded messages.  The writer needs a  Psr\\Logger\\LoggerInterface  instance to be useful, and\nfalls back to  Psr\\Log\\NullLogger  if none is provided. There are three ways to\nprovide the PSR logger instance to the log writer:  // Via constructor parameter:\n$writer = new Zend\\Log\\Writer\\Psr($psrLogger);\n\n// Via option:\n$writer = new Zend\\Log\\Writer\\Psr(['logger' =  $psrLogger]);\n\n// Via setter injection:\n$writer = new Zend\\Log\\Writer\\Psr();\n$writer- setLogger($psrLogger);", 
            "title": "PSR-3 log writer"
        }, 
        {
            "location": "/psr3/#psr-3-placeholder-processor", 
            "text": "Zend\\Log\\Processor\\PsrPlaceholder  adds support for  PSR-3 message placeholders .\nPlaceholder names correspond to keys in the \"extra\" array passed when logging\na message.  Values can be of arbitrary type, including all scalars, and objects\nimplementing  __toString ; objects not capable of string serialization will\nresult in the fully-qualified class name being substituted.  $logger = new Zend\\Log\\Logger;\n$logger- addProcessor(new Zend\\Log\\Processor\\PsrPlaceholder);\n\n$logger- info('User with email {email} registered', ['email' =  'user@example.org']);\n// logs message 'User with email user@example.org registered'", 
            "title": "PSR-3 placeholder processor"
        }
    ]
}